# Ejercicios Resueltos POO con JAVA

Este repositorio nace despu茅s de ver a muchos colegas batallar (y resolver, que conste) problemas complejos con JAVA pero con un enfoque funcional. Que si bien funciona, se pierden la esencia y las ventajas del Paradigma Orientado a Objetos (POO).

> Este repo no es para se帽alar errores, sino para mostrar c贸mo podemos reevaluar y mejorar nuestro c贸digo aplicando conceptos clave que hacen que nuestro software sea m谩s flexible, mantenible y comprensible.

## 驴Qu茅 encontrar谩s aqu铆?
Cada ejercicio en este repositorio aborda un problema sencillo, pero que habitualmente puede generar problemas debido a su naturaleza cambiante o de muchos requerimientos. Ver谩s como aplicando principios de dise帽o OO, principios SOLID y patrones de dise帽o podemos resolver estos problemas de forma elegante.

> El objetivo es que compares, contrastes y veas con tus propios ojos el "por qu茅" de estas pr谩cticas.

###  驴Qu茅 es la Refactorizaci贸n?
Es el proceso de mejorar la estructura interna de tu c贸digo sin alterar su comportamiento externo. No se a帽aden nuevas funciones; al contrario, se ordena, se limpia y se simplifica el dise帽o existente. Es como hacer una puesta a punto al coche: el modelo no cambia, pero funciona de manera m谩s eficiente y es menos probable que se rompa.

### П 驴Qu茅 son los Patrones de Dise帽o?
Son soluciones probadas y reutilizables para problemas comunes de dise帽o de software. No son c贸digo para copiar y pegar, sino planos o recetas que nos gu铆an para estructurar nuestro c贸digo de una manera elegante y robusta. Nos evitan reinventar la rueda cada vez.

### 驴Qu茅 son los Principios SOLID?
Es un acr贸nimo de cinco principios que nos gu铆an para escribir c贸digo OO de alta calidad:

- **S** de _Single Responsibility_ o _Principio de Responsabilidad nica_: Una clase debe tener una, y solo una, raz贸n para cambiar.

- **O** de _Open/Closed_ o _Abierto/Cerrado_: Las clases deben estar abiertas para extensi贸n, pero cerradas para modificaci贸n.

- **L** de _Liskov Substitution_ o _Sustituci贸n de Liskov_: Las clases derivadas deben poder ser usadas en lugar de sus clases base sin alterar el comportamiento correcto del programa.

- **I** de _Interface Segregation_ o _Segrecaci贸n de Interfaces_: Es mejor tener muchas interfaces espec铆ficas que una de prop贸sito general.

- **D** de _Dependency Inversion_ o _Inversi贸n de Dependencias_: Depende de abstracciones, no de implementaciones concretas.

En conjunto, SOLID nos ayuda a crear software que es f谩cil de mantener, extender y testear.

##  Objetivo de este Repositorio
1. Ilustrar la Diferencia: Mostrar el contraste entre un c贸digo que simplemente "funciona" y uno que est谩 bien dise帽ado.
1. Aprender Haciendo: Proveer ejemplos concretos de c贸mo aplicar estos principios para resolver diferentes problemas.
1. Promover el Buen Dise帽o: Incentivar la conversaci贸n sobre c贸mo y por qu茅 dise帽amos nuestro c贸digo de una manera y no de otra.
1. Recuerda: No hay una 煤nica "soluci贸n perfecta". El dise帽o es un arte. La idea es pensar, discutir y aprender juntos.

## 驴C贸mo usar este repo?
Navega a la carpeta de un ejercicio.

Lee primero el c贸digo, son ejercicios cortos 隆Intenta entenderlo!

Haz el ejercicio de incluir nuevos requisitos simples y trata de figurar como podr铆as modificar tu c贸digo actual para cumplir estos requisitos nuevos 驴te complica mucho? 驴tendr铆as que cambiar gran parte de tu c贸digo?

Luego, compara estos ejemplos con tu c贸digo y usalos como ejemplo para refactorizar el tuyo.

Preg煤ntate:

驴Qu茅 problemas ten铆a el primer enfoque?

驴C贸mo los resolvi贸 el segundo?

驴El c贸digo es m谩s f谩cil de leer y extender?

##隆Contribuciones y discusiones son bienvenidas!